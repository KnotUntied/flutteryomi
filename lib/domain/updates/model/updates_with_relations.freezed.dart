// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'updates_with_relations.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;


final _privateConstructorUsedError = UnsupportedError('It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$UpdatesWithRelations {

 int get mangaId => throw _privateConstructorUsedError; String get mangaTitle => throw _privateConstructorUsedError; int get chapterId => throw _privateConstructorUsedError; String get chapterName => throw _privateConstructorUsedError; String? get scanlator => throw _privateConstructorUsedError; bool get read => throw _privateConstructorUsedError; bool get bookmark => throw _privateConstructorUsedError; int get lastPageRead => throw _privateConstructorUsedError; int get sourceId => throw _privateConstructorUsedError; DateTime get dateFetch => throw _privateConstructorUsedError; MangaCover get coverData => throw _privateConstructorUsedError;







@JsonKey(ignore: true)
$UpdatesWithRelationsCopyWith<UpdatesWithRelations> get copyWith => throw _privateConstructorUsedError;

}

/// @nodoc
abstract class $UpdatesWithRelationsCopyWith<$Res>  {
  factory $UpdatesWithRelationsCopyWith(UpdatesWithRelations value, $Res Function(UpdatesWithRelations) then) = _$UpdatesWithRelationsCopyWithImpl<$Res, UpdatesWithRelations>;
@useResult
$Res call({
 int mangaId, String mangaTitle, int chapterId, String chapterName, String? scanlator, bool read, bool bookmark, int lastPageRead, int sourceId, DateTime dateFetch, MangaCover coverData
});


$MangaCoverCopyWith<$Res> get coverData;
}

/// @nodoc
class _$UpdatesWithRelationsCopyWithImpl<$Res,$Val extends UpdatesWithRelations> implements $UpdatesWithRelationsCopyWith<$Res> {
  _$UpdatesWithRelationsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

@pragma('vm:prefer-inline') @override $Res call({Object? mangaId = null,Object? mangaTitle = null,Object? chapterId = null,Object? chapterName = null,Object? scanlator = freezed,Object? read = null,Object? bookmark = null,Object? lastPageRead = null,Object? sourceId = null,Object? dateFetch = null,Object? coverData = null,}) {
  return _then(_value.copyWith(
mangaId: null == mangaId ? _value.mangaId : mangaId // ignore: cast_nullable_to_non_nullable
as int,mangaTitle: null == mangaTitle ? _value.mangaTitle : mangaTitle // ignore: cast_nullable_to_non_nullable
as String,chapterId: null == chapterId ? _value.chapterId : chapterId // ignore: cast_nullable_to_non_nullable
as int,chapterName: null == chapterName ? _value.chapterName : chapterName // ignore: cast_nullable_to_non_nullable
as String,scanlator: freezed == scanlator ? _value.scanlator : scanlator // ignore: cast_nullable_to_non_nullable
as String?,read: null == read ? _value.read : read // ignore: cast_nullable_to_non_nullable
as bool,bookmark: null == bookmark ? _value.bookmark : bookmark // ignore: cast_nullable_to_non_nullable
as bool,lastPageRead: null == lastPageRead ? _value.lastPageRead : lastPageRead // ignore: cast_nullable_to_non_nullable
as int,sourceId: null == sourceId ? _value.sourceId : sourceId // ignore: cast_nullable_to_non_nullable
as int,dateFetch: null == dateFetch ? _value.dateFetch : dateFetch // ignore: cast_nullable_to_non_nullable
as DateTime,coverData: null == coverData ? _value.coverData : coverData // ignore: cast_nullable_to_non_nullable
as MangaCover,
  )as $Val);
}
@override
@pragma('vm:prefer-inline')
$MangaCoverCopyWith<$Res> get coverData {
  
  return $MangaCoverCopyWith<$Res>(_value.coverData, (value) {
    return _then(_value.copyWith(coverData: value) as $Val);
  });
}
}


/// @nodoc
abstract class _$$UpdatesWithRelationsImplCopyWith<$Res> implements $UpdatesWithRelationsCopyWith<$Res> {
  factory _$$UpdatesWithRelationsImplCopyWith(_$UpdatesWithRelationsImpl value, $Res Function(_$UpdatesWithRelationsImpl) then) = __$$UpdatesWithRelationsImplCopyWithImpl<$Res>;
@override @useResult
$Res call({
 int mangaId, String mangaTitle, int chapterId, String chapterName, String? scanlator, bool read, bool bookmark, int lastPageRead, int sourceId, DateTime dateFetch, MangaCover coverData
});


@override $MangaCoverCopyWith<$Res> get coverData;
}

/// @nodoc
class __$$UpdatesWithRelationsImplCopyWithImpl<$Res> extends _$UpdatesWithRelationsCopyWithImpl<$Res, _$UpdatesWithRelationsImpl> implements _$$UpdatesWithRelationsImplCopyWith<$Res> {
  __$$UpdatesWithRelationsImplCopyWithImpl(_$UpdatesWithRelationsImpl _value, $Res Function(_$UpdatesWithRelationsImpl) _then)
      : super(_value, _then);


@pragma('vm:prefer-inline') @override $Res call({Object? mangaId = null,Object? mangaTitle = null,Object? chapterId = null,Object? chapterName = null,Object? scanlator = freezed,Object? read = null,Object? bookmark = null,Object? lastPageRead = null,Object? sourceId = null,Object? dateFetch = null,Object? coverData = null,}) {
  return _then(_$UpdatesWithRelationsImpl(
mangaId: null == mangaId ? _value.mangaId : mangaId // ignore: cast_nullable_to_non_nullable
as int,mangaTitle: null == mangaTitle ? _value.mangaTitle : mangaTitle // ignore: cast_nullable_to_non_nullable
as String,chapterId: null == chapterId ? _value.chapterId : chapterId // ignore: cast_nullable_to_non_nullable
as int,chapterName: null == chapterName ? _value.chapterName : chapterName // ignore: cast_nullable_to_non_nullable
as String,scanlator: freezed == scanlator ? _value.scanlator : scanlator // ignore: cast_nullable_to_non_nullable
as String?,read: null == read ? _value.read : read // ignore: cast_nullable_to_non_nullable
as bool,bookmark: null == bookmark ? _value.bookmark : bookmark // ignore: cast_nullable_to_non_nullable
as bool,lastPageRead: null == lastPageRead ? _value.lastPageRead : lastPageRead // ignore: cast_nullable_to_non_nullable
as int,sourceId: null == sourceId ? _value.sourceId : sourceId // ignore: cast_nullable_to_non_nullable
as int,dateFetch: null == dateFetch ? _value.dateFetch : dateFetch // ignore: cast_nullable_to_non_nullable
as DateTime,coverData: null == coverData ? _value.coverData : coverData // ignore: cast_nullable_to_non_nullable
as MangaCover,
  ));
}


}

/// @nodoc


class _$UpdatesWithRelationsImpl  implements _UpdatesWithRelations {
  const _$UpdatesWithRelationsImpl({required this.mangaId, required this.mangaTitle, required this.chapterId, required this.chapterName, this.scanlator, required this.read, required this.bookmark, required this.lastPageRead, required this.sourceId, required this.dateFetch, required this.coverData});

  

@override final  int mangaId;
@override final  String mangaTitle;
@override final  int chapterId;
@override final  String chapterName;
@override final  String? scanlator;
@override final  bool read;
@override final  bool bookmark;
@override final  int lastPageRead;
@override final  int sourceId;
@override final  DateTime dateFetch;
@override final  MangaCover coverData;

@override
String toString() {
  return 'UpdatesWithRelations(mangaId: $mangaId, mangaTitle: $mangaTitle, chapterId: $chapterId, chapterName: $chapterName, scanlator: $scanlator, read: $read, bookmark: $bookmark, lastPageRead: $lastPageRead, sourceId: $sourceId, dateFetch: $dateFetch, coverData: $coverData)';
}


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _$UpdatesWithRelationsImpl&&(identical(other.mangaId, mangaId) || other.mangaId == mangaId)&&(identical(other.mangaTitle, mangaTitle) || other.mangaTitle == mangaTitle)&&(identical(other.chapterId, chapterId) || other.chapterId == chapterId)&&(identical(other.chapterName, chapterName) || other.chapterName == chapterName)&&(identical(other.scanlator, scanlator) || other.scanlator == scanlator)&&(identical(other.read, read) || other.read == read)&&(identical(other.bookmark, bookmark) || other.bookmark == bookmark)&&(identical(other.lastPageRead, lastPageRead) || other.lastPageRead == lastPageRead)&&(identical(other.sourceId, sourceId) || other.sourceId == sourceId)&&(identical(other.dateFetch, dateFetch) || other.dateFetch == dateFetch)&&(identical(other.coverData, coverData) || other.coverData == coverData));
}


@override
int get hashCode => Object.hash(runtimeType,mangaId,mangaTitle,chapterId,chapterName,scanlator,read,bookmark,lastPageRead,sourceId,dateFetch,coverData);

@JsonKey(ignore: true)
@override
@pragma('vm:prefer-inline')
_$$UpdatesWithRelationsImplCopyWith<_$UpdatesWithRelationsImpl> get copyWith => __$$UpdatesWithRelationsImplCopyWithImpl<_$UpdatesWithRelationsImpl>(this, _$identity);








}


abstract class _UpdatesWithRelations implements UpdatesWithRelations {
  const factory _UpdatesWithRelations({required final  int mangaId, required final  String mangaTitle, required final  int chapterId, required final  String chapterName, final  String? scanlator, required final  bool read, required final  bool bookmark, required final  int lastPageRead, required final  int sourceId, required final  DateTime dateFetch, required final  MangaCover coverData}) = _$UpdatesWithRelationsImpl;
  

  

@override  int get mangaId;@override  String get mangaTitle;@override  int get chapterId;@override  String get chapterName;@override  String? get scanlator;@override  bool get read;@override  bool get bookmark;@override  int get lastPageRead;@override  int get sourceId;@override  DateTime get dateFetch;@override  MangaCover get coverData;
@override @JsonKey(ignore: true)
_$$UpdatesWithRelationsImplCopyWith<_$UpdatesWithRelationsImpl> get copyWith => throw _privateConstructorUsedError;

}
