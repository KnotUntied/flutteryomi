import 'dart:convert';

import 'package:crypto/crypto.dart';
//import 'package:dio/dio.dart';
import 'package:http/http.dart';

import 'package:flutteryomi/domain/source/model/filter_list.dart';
import 'package:flutteryomi/domain/source/model/mangas_page.dart';
import 'package:flutteryomi/domain/source/model/page.dart';
import 'package:flutteryomi/domain/source/model/schapter.dart';
import 'package:flutteryomi/domain/source/model/smanga.dart';
import 'package:flutteryomi/source/api/catalogue_source.dart';

// TODO: Decide between http, dio, or either with a network helper
/// A simple implementation for sources from a website.
abstract class HttpSource extends CatalogueSource {
  HttpSource({
    required super.id,
    required super.name,
    super.lang,
    required super.supportsLatest,
  });

  /// Network service.
  //protected val network: NetworkHelper by injectLazy()

  /// Base url of the website without the trailing slash, like: http://mysite.com
  abstract final String baseUrl;

  /// Version id used to generate the source id. If the site completely changes and urls are
  /// incompatible, you may increase this value and it'll be considered as a new source.
  final versionId = 1;

  /// ID of the source. By default it uses a generated id using the first 16 characters (64 bits)
  /// of the MD5 of the string `"${name.lowercase()}/$lang/$versionId"`.
  ///
  /// The ID is generated by the [generateId] function, which can be reused if needed
  /// to generate outdated IDs for cases where the source name or language needs to
  /// be changed but migrations can be avoided.
  ///
  /// Note: the generated ID sets the sign bit to `0`.
  @override
  int get id => generateId(name, lang, versionId);

  /// Headers used for requests.
  //Headers headers by lazy { headersBuilder().build() };

  /// Default network client for doing requests.
  //OkHttpClient get client = network.client;

  /// Generates a unique ID for the source based on the provided [name], [lang] and
  /// [versionId]. It will use the first 16 characters (64 bits) of the MD5 of the string
  /// `"${name.toLowerCase()}/$lang/$versionId"`.
  ///
  /// Note: the generated ID sets the sign bit to `0`.
  ///
  /// Can be used to generate outdated IDs, such as when the source name or language
  /// needs to be changed but migrations can be avoided.
  int generateId(String name, String lang, int versionId) {
    final key = "${name.toLowerCase()}/$lang/$versionId";
    final bytes = md5.convert(utf8.encode(key)).bytes;
    return bytes
        .sublist(0, 8)
        .map((it) => bytes[it] & 0xff << 8 * (7 - it))
        // Hard-code Kotlin's MAX_VALUE for Long
        // Not sure if this works
        .reduce((a, b) => a | b) & 9223372036854775807;
  }

  /// Headers builder for requests. Implementations can override this method for custom headers.
  //Headers headersBuilder() = Headers.Builder().apply {
  //    add("User-Agent", network.defaultUserAgentProvider())
  //}

  /// Visible name of the source.
  @override
  String toString() => "$name (${lang.toUpperCase()})";

  /// Returns an observable containing a [page] with a list of manga. Normally it's not needed to
  /// override this method.
  //@Deprecated("Use the non-RxJava API instead", replaceWith = ReplaceWith("getPopularManga"))
  //@override
  //fun fetchPopularManga(int page): Observable<MangasPage> {
  //    return client.newCall(popularMangaRequest(page))
  //        .asObservableSuccess()
  //        .map { response ->
  //            popularMangaParse(response)
  //        }
  //}

  /// Returns the request for the popular manga given the page.
  Request popularMangaRequest(int page);

  /// Parses the [response] from the site and returns a [MangasPage] object.
  MangasPage popularMangaParse(Response response);

  /// Returns an observable containing a [page] with a list of manga. Normally it's not needed to
  /// override this method.
  //@Deprecated("Use the non-RxJava API instead", replaceWith = ReplaceWith("getSearchManga"))
  //@override
  //observable instead of future, not sure how for now
  //Future<MangasPage> fetchSearchManga(int page, String query, FilterList filters) {
  //    return Observable.defer {
  //        try {
  //            client.newCall(searchMangaRequest(page, query, filters)).asObservableSuccess()
  //        } catch (e: NoClassDefFoundError) {
  //            // RxJava doesn't handle Errors, which tends to happen during global searches
  //            // if an old extension using non-existent classes is still around
  //            throw RuntimeException(e)
  //        }
  //    }
  //        .map((response) => searchMangaParse(response))
  //}

  /// Returns the request for the search manga given the [page].
  Request searchMangaRequest(int page, String query, FilterList filters);

  /// Parses the [response] from the site and returns a [MangasPage] object.
  MangasPage searchMangaParse(Response response);

  /// Returns an observable containing a [page] with a list of latest manga updates.
  //@Deprecated("Use the non-RxJava API instead", replaceWith = ReplaceWith("getLatestUpdates"))
  //@override
  //observable
  //Future<MangasPage> fetchLatestUpdates(int page) {
  //    return client.newCall(latestUpdatesRequest(page))
  //        .asObservableSuccess()
  //        .map((response) => latestUpdatesParse(response));
  //}

  /// Returns the request for latest manga given the [page].
  Request latestUpdatesRequest(int page);

  /// Parses the [response] from the site and returns a [MangasPage] object.
  MangasPage latestUpdatesParse(Response response);

  /// Get the updated details for a [manga].
  /// Normally it's not needed to override this method.
  ///
  /// Returns the updated manga.
  //@override
  //Future<SManga> getMangaDetails(SManga manga) {
  //  return fetchMangaDetails(manga).awaitSingle();
  //}

  //@override
  //Observable<SManga> fetchMangaDetails(SManga manga) {
  //    return client.newCall(mangaDetailsRequest(manga))
  //        .asObservableSuccess()
  //        .map { response ->
  //            mangaDetailsParse(response).apply { initialized = true }
  //        }
  //}

  /// Returns the request for the details of a [manga]. Override only if it's needed to change the
  /// url, send different headers or request method like POST.
  //Request mangaDetailsRequest(SManga manga) {
  //    return GET(baseUrl + manga.url, headers)
  //}

  /// Parses the [response] from the site and returns the details of a manga.
  SManga mangaDetailsParse(Response response);

  /// Get all the available chapters for a [manga].
  /// Normally it's not needed to override this method.
  /// Throws a LicensedMangaChaptersException if a manga is licensed and therefore no chapters are available.
  @override
  Future<List<SChapter>> getChapterList(SManga manga) async {
    if (manga.status == SManga.licensed) throw LicensedMangaChaptersException();
    //return fetchChapterList(manga).awaitSingle();
    return [];
  }

  //@Deprecated("Use the non-RxJava API instead", replaceWith = ReplaceWith("getChapterList"))
  //@override Observable<List<SChapter>> fetchChapterList(SManga manga) {
  //    return if (manga.status != SManga.LICENSED) {
  //        client.newCall(chapterListRequest(manga))
  //            .asObservableSuccess()
  //            .map { response ->
  //                chapterListParse(response)
  //            }
  //    } else {
  //        Observable.error(LicensedMangaChaptersException())
  //    }
  //}

  /// Returns the request for updating the chapter list. Override only if it's needed to override
  /// the url, send different headers or request method like POST.
  //Request chapterListRequest(SManga manga) {
      //return GET(baseUrl + manga.url, headers)
  //}

  /// Parses the [response] from the site and returns a list of chapters.
  List<SChapter> chapterListParse(Response response);

  /// Parses the [response] from the site and returns a SChapter Object.
  SChapter chapterPageParse(Response response);

  /// Get the list of pages a [chapter] has. Pages should be returned
  /// in the expected order; the index is ignored.
  @override
  Future<List<Page>> getPageList(SChapter chapter) async {
    //return fetchPageList(chapter).awaitSingle();
    return [];
  }

  //@Deprecated("Use the non-RxJava API instead", replaceWith = ReplaceWith("getPageList"))
  //@override
  //Observable<List<Page>> fetchPageList(SChapter chapter) {
  //    return client.newCall(pageListRequest(chapter))
  //        .asObservableSuccess()
  //        .map { response ->
  //            pageListParse(response)
  //        }
  //}

  /// Returns the request for getting the page list. Override only if it's needed to override the
  /// url, send different headers or request method like POST.
  //Request pageListRequest(SChapter chapter) {
  //  return GET(baseUrl + chapter.url, headers);
  //}

  /// Parses the [response] from the site and returns a list of pages.
  List<Page> pageListParse(Response response);

  /// Returns an observable with the [page] containing the source url of the image. If there's any
  /// error, it will return null instead of throwing an exception.
  //@Suppress("DEPRECATION")
  //Future<String> getImageUrl(Page page) {
  //    return fetchImageUrl(page).awaitSingle()
  //}

  //@Deprecated("Use the non-RxJava API instead", replaceWith = ReplaceWith("getImageUrl"))
  //Observable<String> fetchImageUrl(Page page) {
  //    return client.newCall(imageUrlRequest(page))
  //        .asObservableSuccess()
  //        .map { imageUrlParse(it) }
  //}

  /// Returns the request for getting the url to the source image. Override only if it's needed to
  /// override the url, send different headers or request method like POST.
  //Request imageUrlRequest(Page page) {
  //  return GET(page.url, headers);
  //}

  /// Parses the [response] from the site and returns the absolute url to the source image.
  String imageUrlParse(Response response);

  /// Returns the response of the source image.
  /// Typically does not need to be overridden.
  //Future<Response> getImage(Page page) async {
  //  return client.newCachelessCallWithProgress(imageRequest(page), page)
  //      .awaitSuccess();
  //}

  /// Returns the request for getting the source image. Override only if it's needed to override
  /// the url, send different headers or request method like POST.
  //Request imageRequest(Page page) {
  //    return GET(page.imageUrl!, headers);
  //}

  /// Returns the [url] of the provided [manga]
  //String getMangaUrl(SManga manga) =>
  //    mangaDetailsRequest(manga).url.toString();

  /// Returns the [url] of the provided [chapter]
  //String getChapterUrl(SChapter chapter) =>
  //    pageListRequest(chapter).url.toString();

  /// Called before inserting a new chapter into database. Use it if you need to override chapter
  /// fields, like the title or the chapter number. Do not change anything to [manga].
  void prepareNewChapter(SChapter chapter, SManga manga);

  /// Returns the list of filters for the source.
  @override
  FilterList getFilterList() => [];
}

extension SChapterHttpSource on SChapter {
  /// Assigns the url of the chapter without the scheme and domain. It saves some redundancy from
  /// database and the urls could still work after a domain change.
  void setUrlWithoutDomain(String url) {
    url = _getUrlWithoutDomain(url);
  }

  /// Returns the url of the given string without the scheme and domain.
  String _getUrlWithoutDomain(String orig) {
    try {
      return Uri.parse(orig.replaceAll(" ", "%20")).path;
    } catch (e) {
      return orig;
    }
  }
}

extension SMangaHttpSource on SManga {
  /// Assigns the url of the manga without the scheme and domain. It saves some redundancy from
  /// database and the urls could still work after a domain change.
  void setUrlWithoutDomain(String url) {
    url = _getUrlWithoutDomain(url);
  }

  /// Returns the url of the given string without the scheme and domain.
  String _getUrlWithoutDomain(String orig) {
    try {
      return Uri.parse(orig.replaceAll(" ", "%20")).path;
    } catch (e) {
      return orig;
    }
  }
}

class LicensedMangaChaptersException implements Exception {}
